// AGREGAR ESTO AL ARCHIVO: src/auth/auth.controller.ts

// 1. ACTUALIZAR LOS IMPORTS (en la parte superior del archivo)
import {
  Controller,
  Post,
  Get,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
  Req,
  Res,
  Logger,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto, LoginDto, AuthResponseDto } from './auth.dto';
import { GitHubAuthGuard } from '../guard/github.guard';
import { GoogleAuthGuard } from '../guard/google.guard';  // AGREGAR ESTO
import { DiscordAuthGuard } from '../guard/discord.guard'; // AGREGAR ESTO
import { Public } from '../guard/public.decorator';
import { User } from '../guard/user.decorator';
import type { Response, Request } from 'express';
import type { User as UserType } from 'prisma/generated/prisma';

// 2. AGREGAR ESTAS RUTAS EN LA CLASE AuthController después del método githubCallback()

/**
 * Iniciar autenticación con Google
 * GET /auth/google
 * Ruta PÚBLICA - Redirige a Google
 */
@Get('google')
@Public()
@UseGuards(GoogleAuthGuard)
async googleAuth(): Promise<void> {
  // Guard redirige a Google
}

/**
 * Callback de Google OAuth
 * GET /auth/google/callback
 * Ruta PÚBLICA - Recibe callback de Google
 */
@Get('google/callback')
@Public()
@UseGuards(GoogleAuthGuard)
googleCallback(@Req() req: Request, @Res() res: Response): void {
  try {
    const authResponse = req.user as unknown as AuthResponseDto;

    this.logger.log(`Google callback successful for: ${authResponse.email}`);

    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    const redirectUrl = `${frontendUrl}/auth/callback?token=${authResponse.access_token}&user=${encodeURIComponent(JSON.stringify(authResponse))}`;

    res.redirect(redirectUrl);
  } catch (error) {
    this.logger.error('Google callback error', error);
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    res.redirect(`${frontendUrl}/auth/error`);
  }
}

/**
 * Iniciar autenticación con Discord
 * GET /auth/discord
 * Ruta PÚBLICA - Redirige a Discord
 */
@Get('discord')
@Public()
@UseGuards(DiscordAuthGuard)
async discordAuth(): Promise<void> {
  // Guard redirige a Discord
}

/**
 * Callback de Discord OAuth
 * GET /auth/discord/callback
 * Ruta PÚBLICA - Recibe callback de Discord
 */
@Get('discord/callback')
@Public()
@UseGuards(DiscordAuthGuard)
discordCallback(@Req() req: Request, @Res() res: Response): void {
  try {
    const authResponse = req.user as unknown as AuthResponseDto;

    this.logger.log(`Discord callback successful for: ${authResponse.email}`);

    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    const redirectUrl = `${frontendUrl}/auth/callback?token=${authResponse.access_token}&user=${encodeURIComponent(JSON.stringify(authResponse))}`;

    res.redirect(redirectUrl);
  } catch (error) {
    this.logger.error('Discord callback error', error);
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    res.redirect(`${frontendUrl}/auth/error`);
  }
}
